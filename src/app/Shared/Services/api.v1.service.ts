/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Authors
     * @param searchString (optional) 
     * @return Success
     */
    getAuthors(searchString?: string | undefined): Observable<GetAuthorResponseModel> {
        let url_ = this.baseUrl + "/api/authors?";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "SearchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthors(<any>response_);
                } catch (e) {
                    return <Observable<GetAuthorResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAuthorResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthors(response: HttpResponseBase): Observable<GetAuthorResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAuthorResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAuthorResponseModel>(<any>null);
    }

    /**
     * Update Author
     * @param body (optional) 
     * @return Success
     */
    updateAuthor(body?: UpdateAuthorRequestModel | undefined): Observable<UpdateAuthorResponseModel> {
        let url_ = this.baseUrl + "/api/authors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthor(<any>response_);
                } catch (e) {
                    return <Observable<UpdateAuthorResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateAuthorResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAuthor(response: HttpResponseBase): Observable<UpdateAuthorResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAuthorResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateAuthorResponseModel>(<any>null);
    }
}

@Injectable()
export class BooksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Books
     * @param keyword (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getBooks(keyword?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetBooksReponseModel> {
        let url_ = this.baseUrl + "/api/books?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBooks(<any>response_);
                } catch (e) {
                    return <Observable<GetBooksReponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBooksReponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetBooks(response: HttpResponseBase): Observable<GetBooksReponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBooksReponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBooksReponseModel>(<any>null);
    }

    /**
     * Update a book
     * @param body (optional) 
     * @return Success
     */
    updateBook(body?: UpdateBookRequestModel | undefined): Observable<UpdateBooksResponseModel> {
        let url_ = this.baseUrl + "/api/books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBook(<any>response_);
                } catch (e) {
                    return <Observable<UpdateBooksResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateBooksResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBook(response: HttpResponseBase): Observable<UpdateBooksResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateBooksResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateBooksResponseModel>(<any>null);
    }

    /**
     * Get Book by Id
     * @return Success
     */
    getBookById(id: number): Observable<GetBookByIdResponseMode> {
        let url_ = this.baseUrl + "/api/books/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookById(<any>response_);
                } catch (e) {
                    return <Observable<GetBookByIdResponseMode>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBookByIdResponseMode>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookById(response: HttpResponseBase): Observable<GetBookByIdResponseMode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBookByIdResponseMode.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBookByIdResponseMode>(<any>null);
    }

    /**
     * Get Books by Genres
     * @param genres (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getBooksByGenre(genres?: GenreModel[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetFilterBooksByGenreResponseModel> {
        let url_ = this.baseUrl + "/api/filteredBooks?";
        if (genres === null)
            throw new Error("The parameter 'genres' cannot be null.");
        else if (genres !== undefined)
            genres && genres.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Genres[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBooksByGenre(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBooksByGenre(<any>response_);
                } catch (e) {
                    return <Observable<GetFilterBooksByGenreResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFilterBooksByGenreResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetBooksByGenre(response: HttpResponseBase): Observable<GetFilterBooksByGenreResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFilterBooksByGenreResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFilterBooksByGenreResponseModel>(<any>null);
    }
}

@Injectable()
export class GenreClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Genres
     * @return Success
     */
    getGenres(): Observable<GetGenresResponseModel> {
        let url_ = this.baseUrl + "/api/genre";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGenres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGenres(<any>response_);
                } catch (e) {
                    return <Observable<GetGenresResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGenresResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetGenres(response: HttpResponseBase): Observable<GetGenresResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGenresResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGenresResponseModel>(<any>null);
    }
}

export class AuthorAndBooksModel implements IAuthorAndBooksModel {
    id?: number | undefined;
    authorName?: string | undefined;
    bookTitles?: string[] | undefined;

    constructor(data?: IAuthorAndBooksModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorName = _data["authorName"];
            if (Array.isArray(_data["bookTitles"])) {
                this.bookTitles = [] as any;
                for (let item of _data["bookTitles"])
                    this.bookTitles!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthorAndBooksModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorAndBooksModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorName"] = this.authorName;
        if (Array.isArray(this.bookTitles)) {
            data["bookTitles"] = [];
            for (let item of this.bookTitles)
                data["bookTitles"].push(item);
        }
        return data; 
    }
}

export interface IAuthorAndBooksModel {
    id?: number | undefined;
    authorName?: string | undefined;
    bookTitles?: string[] | undefined;
}

export class AuthorModel implements IAuthorModel {
    id?: number | undefined;
    authorName?: string | undefined;

    constructor(data?: IAuthorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.authorName = _data["authorName"];
        }
    }

    static fromJS(data: any): AuthorModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["authorName"] = this.authorName;
        return data; 
    }
}

export interface IAuthorModel {
    id?: number | undefined;
    authorName?: string | undefined;
}

export class BookModel implements IBookModel {
    id?: number;
    isbn?: string | undefined;
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    seriesName?: string | undefined;
    seriesOrder?: number | undefined;
    genres?: GenreModel[] | undefined;
    publishedDate?: string | undefined;
    goodreadsLink?: string | undefined;
    rating?: number | undefined;
    totalReviews?: number | undefined;
    bookCoverHighResUrl?: string | undefined;
    bookCoverThumbnailResUrl?: string | undefined;
    bookCoverLowResUrl?: string | undefined;
    bookCoverMediumResUrl?: string | undefined;
    bookCoverUrl?: string | undefined;
    coverColour?: string | undefined;

    constructor(data?: IBookModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isbn = _data["isbn"];
            this.title = _data["title"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorModel.fromJS(item));
            }
            this.seriesName = _data["seriesName"];
            this.seriesOrder = _data["seriesOrder"];
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreModel.fromJS(item));
            }
            this.publishedDate = _data["publishedDate"];
            this.goodreadsLink = _data["goodreadsLink"];
            this.rating = _data["rating"];
            this.totalReviews = _data["totalReviews"];
            this.bookCoverHighResUrl = _data["bookCoverHighResUrl"];
            this.bookCoverThumbnailResUrl = _data["bookCoverThumbnailResUrl"];
            this.bookCoverLowResUrl = _data["bookCoverLowResUrl"];
            this.bookCoverMediumResUrl = _data["bookCoverMediumResUrl"];
            this.bookCoverUrl = _data["bookCoverUrl"];
            this.coverColour = _data["coverColour"];
        }
    }

    static fromJS(data: any): BookModel {
        data = typeof data === 'object' ? data : {};
        let result = new BookModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isbn"] = this.isbn;
        data["title"] = this.title;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        data["seriesName"] = this.seriesName;
        data["seriesOrder"] = this.seriesOrder;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["publishedDate"] = this.publishedDate;
        data["goodreadsLink"] = this.goodreadsLink;
        data["rating"] = this.rating;
        data["totalReviews"] = this.totalReviews;
        data["bookCoverHighResUrl"] = this.bookCoverHighResUrl;
        data["bookCoverThumbnailResUrl"] = this.bookCoverThumbnailResUrl;
        data["bookCoverLowResUrl"] = this.bookCoverLowResUrl;
        data["bookCoverMediumResUrl"] = this.bookCoverMediumResUrl;
        data["bookCoverUrl"] = this.bookCoverUrl;
        data["coverColour"] = this.coverColour;
        return data; 
    }
}

export interface IBookModel {
    id?: number;
    isbn?: string | undefined;
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    seriesName?: string | undefined;
    seriesOrder?: number | undefined;
    genres?: GenreModel[] | undefined;
    publishedDate?: string | undefined;
    goodreadsLink?: string | undefined;
    rating?: number | undefined;
    totalReviews?: number | undefined;
    bookCoverHighResUrl?: string | undefined;
    bookCoverThumbnailResUrl?: string | undefined;
    bookCoverLowResUrl?: string | undefined;
    bookCoverMediumResUrl?: string | undefined;
    bookCoverUrl?: string | undefined;
    coverColour?: string | undefined;
}

export class GenreModel implements IGenreModel {
    id?: number | undefined;
    genreName?: string | undefined;

    constructor(data?: IGenreModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.genreName = _data["genreName"];
        }
    }

    static fromJS(data: any): GenreModel {
        data = typeof data === 'object' ? data : {};
        let result = new GenreModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["genreName"] = this.genreName;
        return data; 
    }
}

export interface IGenreModel {
    id?: number | undefined;
    genreName?: string | undefined;
}

export class GetAuthorResponseModel implements IGetAuthorResponseModel {
    success?: boolean;
    message?: string | undefined;
    authorAndBooks?: AuthorAndBooksModel[] | undefined;

    constructor(data?: IGetAuthorResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            if (Array.isArray(_data["authorAndBooks"])) {
                this.authorAndBooks = [] as any;
                for (let item of _data["authorAndBooks"])
                    this.authorAndBooks!.push(AuthorAndBooksModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAuthorResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuthorResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        if (Array.isArray(this.authorAndBooks)) {
            data["authorAndBooks"] = [];
            for (let item of this.authorAndBooks)
                data["authorAndBooks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAuthorResponseModel {
    success?: boolean;
    message?: string | undefined;
    authorAndBooks?: AuthorAndBooksModel[] | undefined;
}

export class GetBookByIdResponseMode implements IGetBookByIdResponseMode {
    success?: boolean;
    message?: string | undefined;
    book?: BookModel;

    constructor(data?: IGetBookByIdResponseMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.book = _data["book"] ? BookModel.fromJS(_data["book"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBookByIdResponseMode {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookByIdResponseMode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["book"] = this.book ? this.book.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBookByIdResponseMode {
    success?: boolean;
    message?: string | undefined;
    book?: BookModel;
}

export class GetBooksReponseModel implements IGetBooksReponseModel {
    success?: boolean;
    message?: string | undefined;
    currentPage?: number;
    currentPageSize?: number;
    totalPages?: number;
    totalItems?: number;
    books?: BookModel[] | undefined;

    constructor(data?: IGetBooksReponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.currentPage = _data["currentPage"];
            this.currentPageSize = _data["currentPageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["books"])) {
                this.books = [] as any;
                for (let item of _data["books"])
                    this.books!.push(BookModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetBooksReponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetBooksReponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["currentPage"] = this.currentPage;
        data["currentPageSize"] = this.currentPageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.books)) {
            data["books"] = [];
            for (let item of this.books)
                data["books"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetBooksReponseModel {
    success?: boolean;
    message?: string | undefined;
    currentPage?: number;
    currentPageSize?: number;
    totalPages?: number;
    totalItems?: number;
    books?: BookModel[] | undefined;
}

export class GetFilterBooksByGenreResponseModel implements IGetFilterBooksByGenreResponseModel {
    success?: boolean;
    message?: string | undefined;
    currentPage?: number;
    currentPageSize?: number;
    totalPages?: number;
    totalItems?: number;
    books?: PublicBookModel[] | undefined;

    constructor(data?: IGetFilterBooksByGenreResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.currentPage = _data["currentPage"];
            this.currentPageSize = _data["currentPageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["books"])) {
                this.books = [] as any;
                for (let item of _data["books"])
                    this.books!.push(PublicBookModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFilterBooksByGenreResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetFilterBooksByGenreResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["currentPage"] = this.currentPage;
        data["currentPageSize"] = this.currentPageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.books)) {
            data["books"] = [];
            for (let item of this.books)
                data["books"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetFilterBooksByGenreResponseModel {
    success?: boolean;
    message?: string | undefined;
    currentPage?: number;
    currentPageSize?: number;
    totalPages?: number;
    totalItems?: number;
    books?: PublicBookModel[] | undefined;
}

export class GetGenresResponseModel implements IGetGenresResponseModel {
    success?: boolean;
    message?: string | undefined;
    genres?: GenreModel[] | undefined;

    constructor(data?: IGetGenresResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGenresResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetGenresResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetGenresResponseModel {
    success?: boolean;
    message?: string | undefined;
    genres?: GenreModel[] | undefined;
}

export class PublicBookModel implements IPublicBookModel {
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    genres?: GenreModel[] | undefined;
    bookCoverThumbnail?: string | undefined;
    bookCoverLow?: string | undefined;
    bookCoverMedium?: string | undefined;
    bookCoverBgColour?: string | undefined;
    goodReadsLink?: string | undefined;

    constructor(data?: IPublicBookModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorModel.fromJS(item));
            }
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreModel.fromJS(item));
            }
            this.bookCoverThumbnail = _data["bookCoverThumbnail"];
            this.bookCoverLow = _data["bookCoverLow"];
            this.bookCoverMedium = _data["bookCoverMedium"];
            this.bookCoverBgColour = _data["bookCoverBgColour"];
            this.goodReadsLink = _data["goodReadsLink"];
        }
    }

    static fromJS(data: any): PublicBookModel {
        data = typeof data === 'object' ? data : {};
        let result = new PublicBookModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["bookCoverThumbnail"] = this.bookCoverThumbnail;
        data["bookCoverLow"] = this.bookCoverLow;
        data["bookCoverMedium"] = this.bookCoverMedium;
        data["bookCoverBgColour"] = this.bookCoverBgColour;
        data["goodReadsLink"] = this.goodReadsLink;
        return data; 
    }
}

export interface IPublicBookModel {
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    genres?: GenreModel[] | undefined;
    bookCoverThumbnail?: string | undefined;
    bookCoverLow?: string | undefined;
    bookCoverMedium?: string | undefined;
    bookCoverBgColour?: string | undefined;
    goodReadsLink?: string | undefined;
}

export class UpdateAuthorRequestModel implements IUpdateAuthorRequestModel {
    authorId?: number | undefined;
    authorName?: string | undefined;

    constructor(data?: IUpdateAuthorRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authorId = _data["authorId"];
            this.authorName = _data["authorName"];
        }
    }

    static fromJS(data: any): UpdateAuthorRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorId"] = this.authorId;
        data["authorName"] = this.authorName;
        return data; 
    }
}

export interface IUpdateAuthorRequestModel {
    authorId?: number | undefined;
    authorName?: string | undefined;
}

export class UpdateAuthorResponseModel implements IUpdateAuthorResponseModel {
    success?: boolean;
    message?: string | undefined;
    updatedAuthorId?: number;

    constructor(data?: IUpdateAuthorResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.updatedAuthorId = _data["updatedAuthorId"];
        }
    }

    static fromJS(data: any): UpdateAuthorResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["updatedAuthorId"] = this.updatedAuthorId;
        return data; 
    }
}

export interface IUpdateAuthorResponseModel {
    success?: boolean;
    message?: string | undefined;
    updatedAuthorId?: number;
}

export class UpdateBookRequestModel implements IUpdateBookRequestModel {
    id?: number | undefined;
    isbn?: string | undefined;
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    seriesName?: string | undefined;
    seriesOrder?: number | undefined;
    genres?: GenreModel[] | undefined;
    publishedDate?: string | undefined;
    goodreadsLink?: string | undefined;
    rating?: number | undefined;
    totalReviews?: number | undefined;
    bookCoverThumbnail?: string | undefined;
    bookCoverLowResUrl?: string | undefined;
    bookCoverMediumResUrl?: string | undefined;
    bookCoverHighResUrl?: string | undefined;
    bookCoverUrl?: string | undefined;
    coverColour?: string | undefined;

    constructor(data?: IUpdateBookRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isbn = _data["isbn"];
            this.title = _data["title"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorModel.fromJS(item));
            }
            this.seriesName = _data["seriesName"];
            this.seriesOrder = _data["seriesOrder"];
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreModel.fromJS(item));
            }
            this.publishedDate = _data["publishedDate"];
            this.goodreadsLink = _data["goodreadsLink"];
            this.rating = _data["rating"];
            this.totalReviews = _data["totalReviews"];
            this.bookCoverThumbnail = _data["bookCoverThumbnail"];
            this.bookCoverLowResUrl = _data["bookCoverLowResUrl"];
            this.bookCoverMediumResUrl = _data["bookCoverMediumResUrl"];
            this.bookCoverHighResUrl = _data["bookCoverHighResUrl"];
            this.bookCoverUrl = _data["bookCoverUrl"];
            this.coverColour = _data["coverColour"];
        }
    }

    static fromJS(data: any): UpdateBookRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isbn"] = this.isbn;
        data["title"] = this.title;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        data["seriesName"] = this.seriesName;
        data["seriesOrder"] = this.seriesOrder;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["publishedDate"] = this.publishedDate;
        data["goodreadsLink"] = this.goodreadsLink;
        data["rating"] = this.rating;
        data["totalReviews"] = this.totalReviews;
        data["bookCoverThumbnail"] = this.bookCoverThumbnail;
        data["bookCoverLowResUrl"] = this.bookCoverLowResUrl;
        data["bookCoverMediumResUrl"] = this.bookCoverMediumResUrl;
        data["bookCoverHighResUrl"] = this.bookCoverHighResUrl;
        data["bookCoverUrl"] = this.bookCoverUrl;
        data["coverColour"] = this.coverColour;
        return data; 
    }
}

export interface IUpdateBookRequestModel {
    id?: number | undefined;
    isbn?: string | undefined;
    title?: string | undefined;
    authors?: AuthorModel[] | undefined;
    seriesName?: string | undefined;
    seriesOrder?: number | undefined;
    genres?: GenreModel[] | undefined;
    publishedDate?: string | undefined;
    goodreadsLink?: string | undefined;
    rating?: number | undefined;
    totalReviews?: number | undefined;
    bookCoverThumbnail?: string | undefined;
    bookCoverLowResUrl?: string | undefined;
    bookCoverMediumResUrl?: string | undefined;
    bookCoverHighResUrl?: string | undefined;
    bookCoverUrl?: string | undefined;
    coverColour?: string | undefined;
}

export class UpdateBooksResponseModel implements IUpdateBooksResponseModel {
    success?: boolean;
    message?: string | undefined;
    bookId?: number | undefined;

    constructor(data?: IUpdateBooksResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.bookId = _data["bookId"];
        }
    }

    static fromJS(data: any): UpdateBooksResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBooksResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["bookId"] = this.bookId;
        return data; 
    }
}

export interface IUpdateBooksResponseModel {
    success?: boolean;
    message?: string | undefined;
    bookId?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}